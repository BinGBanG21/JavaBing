public class DesignCode {
    public static void main(String[] args) {

    }
    /*
    1. 范式都包括哪些
        目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式 （2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
        数据库的范式设计越高阶，夯余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范的要求称为第二范式（2NF），其余范式以此类推。
        一般来说，在关系型数据库设计中，最高也就遵循到`BCNF`, 普遍还是`3NF`。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是`反规范化`。
    2. 第一范式(1st NF)
        第一范式主要确保数据库中每个字段的值必须具有`原子性`，也就是说数据表中每个字段的值为`不可再次拆分`的最小数据单元。
    3. 第二范式(2nd NF)
        第二范式要求，在满足第一范式的基础上，还要满足数据库里的每一条数据记录，都是可唯一标识的。
        而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。
        如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以扩展替换为候选键）。
    4. 第三范式(3rd NF)
        第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。
        （即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A->B->C"的决定关系）
        该规则的意思是所有`非主键属性`之间不能由依赖关系，必须`相互独立`。
    5. 反范式化
       规范化 vs 性能
        > 1. 为满足某种商业目标 , 数据库性能比规范化数据库更重要
        > 2. 在数据规范化的同时 , 要综合考虑数据库的性能
        > 3. 通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间
        > 4. 通过在给定的表中插入计算列，以方便查询
    6. 反范式的新问题
        * 存储空间变大了
        * 一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致
        * 若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源
        * 在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂
    7. 反范式的适用场景
        当冗余信息有价值或者能 `大幅度提高查询效率` 的时候，我们才会采取反范式的优化。
        1. 增加冗余字段的建议
            增加冗余字段一定要符合如下两个条件。只要满足这两个条件，才可以考虑增加夯余字段。
            1）这个冗余字段`不需要经常进行修改`。
            2）这个冗余字段`查询的时候不可或缺`。
        2. 历史快照、历史数据的需要
            在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每 次发生的 `订单收货信息` 都属于 `历史快照` ，需要进行保存，但用户可以随时修改自己的信息，这时保存这 些冗余信息是非常有必要的。
            反范式优化也常用在 `数据仓库` 的设计中，因为数据仓库通常`存储历史数据` ，对增删改的实时性要求不 强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。
            数据仓库和数据库在使用上的区别：
                1. 数据库设计的目的在于`捕捉数据`，而数据仓库设计的目的在于`分析数据`。
                2. 数据库对数据的`增删改实时性`要求强，需要存储在线的用户数据，而数据仓库存储的一般是`历史数据`。
                3. 数据库设计需要`尽量避免冗余`，但为了提高查询效率也允许一定的`冗余度`，而数据仓库在设计上更偏向采用反范式设计，


     */
}
