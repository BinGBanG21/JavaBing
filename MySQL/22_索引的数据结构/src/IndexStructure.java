public class IndexStructure {
    public static void main(String[] args) {

    }
    /*
    1. 索引
        索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。
        MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则`通过索引查找`相关数据，
        如果不符合则需要`全表扫描`，即需要一条一条地查找记录，直到找到与条件符合的记录。
        数据库没有索引的情况下，数据`分布在硬盘不同的位置上面`，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。
        如果`数据顺序摆放`，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，`依旧非常耗时`。
        如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 = 89 这条记录，就要逐行去查找、去比较。
        从Col 2 = 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有`上千万条数据`，
        就意味着要做`很多很多次硬盘I/0`才能找到。现在要查找 Col 2 = 89 这条记录。CPU必须先去磁盘查找这条记录，
        找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I/O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）
    2. 索引及其优缺点
        2.1 索引概述
            MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。
            索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 `高级查找算法` 。
            `索引是在存储引擎中实现的`，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。
            同时，存储引擎可以定义每个表的 `最大索引数`和 `最大索引长度`所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节有些存储引擎支持更多的索引数和更大的索引长度。
        2.2 优点
            （1）类似大学图书馆建书目索引，提高数据检索的效率，降低 **数据库的IO成本** ，这也是创建索引最主 要的原因。
            （2）通过创建唯一索引，可以保证数据库表中每一行 **数据的唯一性** 。
            （3）在实现数据的 参考完整性方面，可以 **加速表和表之间的连接** 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。
            （4）在使用分组和排序子句进行数据查询时，可以显著 **减少查询中分组和排序的时间** ，降低了CPU的消耗。
        2.3 缺点
        增加索引也有许多不利的方面，主要表现在如下几个方面：
            （1）创建索引和维护索引要 **耗费时间** ，并 且随着数据量的增加，所耗费的时间也会增加。
            （2）索引需要占 **磁盘空间** ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。
            （3）虽然索引大大提高了查询速度，同时却会 降低更新表的速度。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。
                 因此，选择使用索引时，需要综合考虑索引的优点和缺点。
    3. InnoDB中索引的推演
        3.1 索引之前的查找
            1. 在一个页中的查找
                假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：
                * 以主键为搜索条件
                  可以在页目录中使用 `二分法` 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。
                * 以其他列作为搜索条件
                  因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。
                  这种情况下只能从 `最小记录` 开始 `依次遍历单链表中的每条记录`， 然后对比每条记录是不是符合搜索条件。
                  很显然，这种查找的效率是非常低的。
           2. 在很多页中查找
                在很多页中查找记录的活动可以分为两个步骤：
                    1. 定位到记录所在的页。
                    2. 从所在的页内中查找相应的记录。
                    在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页沿着双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。
                    因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。
        3.2 InnoDB中的索引方案
            ① 迭代1次：目录项纪录的页
            ② 迭代2次：多个目录项纪录的页
            ③ 迭代3次：目录项记录页的目录页
            ④ B+Tree
            一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。
            其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么：
                * 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。
                * 如果B+树有2层，最多能存放 1000×100=10,0000 条记录。
                * 如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。
                * 如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！
                你的表里能存放 **100000000000** 条记录吗？所以一般情况下，我们用到的B+树都不会超过4层 ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页）
                又因为在每个页面内有所谓的Page Directory(页目录)，所以在页面内也可以通过二分法实现快速 定位记录。
        3.3 常见索引概念
            索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。
            1. 聚簇索引
                聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在了叶子结点），也就是所谓的 `索引即数据，数据即索引`。
            特点：
                * 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
                  * `页内` 的记录是按照主键的大小顺序排成一个 `单向链表` 。
                  * 各个存放 `用户记录的页` 也是根据页中用户记录的主键大小顺序排成一个 `双向链表` 。
                  * 存放 `目录项记录的页` 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 `双向链表` 。
                * B+树的 叶子节点 存储的是完整的用户记录。
                  所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。
                  我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处。
                  这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建，`InnDB` 存储引擎会自动的为我们创建聚簇索引。
                优点：
                    * `数据访问更快` ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
                    * 聚簇索引对于主键的 `排序查找` 和 `范围查找` 速度非常快
                    * 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 `节省了大量的io操作` 。
                缺点：
                    * `插入速度严重依赖于插入顺序` ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个`自增的ID列为主键`
                    * `更新主键的代价很高` ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**主键为不可更新**
                    * `二级索引访问需要两次索引查找` ，第一次找到主键值，第二次根据主键值找到行数据
            2. 二级索引（辅助索引、非聚簇索引）
                如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。
                所以可以`多建几颗B+树`，不同的B+树中的数据采用不同的排列规则。
                比方说我们用`c2`列的大小作为数据页、页中记录的排序规则，再建一课B+树
                概念：回表
                我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。
                也就 是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树
            3.联合索引
                我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义：
                * 先把各个记录和页按照c2列进行排序。
                * 在记录的c2列相同的情况下，采用c3列进行排序


     */
}
