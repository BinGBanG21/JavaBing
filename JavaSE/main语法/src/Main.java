/*
* 深入理解 main 方法
*   main方法的形式∶public static void main（String【】args）
*   1.main方法是虚拟机调用
    2.java虚拟机需要调用类的main（）方法，所以该方法的访问权限必须是public
    3. java虚拟机在执行main（）方法时不必创建对象，所以该方法必须是static
    4. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数
    5.java执行的程序参数1参数2参数3
  main方法注意
    1) 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。
    2) 但是不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员
  代码块
    基本介绍
       代码化块又称为初始化块，属于类中的成员【即是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。
       但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。
    基本语法
        【修饰符】{
           代码
         }
    说明注意
        1）修饰符可选，要写的话，也只能写static
        2）代码块分为两类，使用static 修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块。
        3）逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）
        4）；号可以写上，也可以省略。
    代码块的好处
        1）相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作
        2）场景∶如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性
        举例
          (1) 下面的三个构造器都有相同的语句
          (2) 这样代码看起来比较冗余
          (3) 这时我们可以把相同的语句，放入到一个代码块中，即可
          (4) 这样当我们不管调用哪个构造器，创建对象，都会先调用代码块的内容
          (5) 代码块调用的顺序优先于构造器
    代码块使用注意事项
        1）static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。
            如果是普通代码块，每创建一个对象，就执行。
        2）类什么时候被加载
            ①创建对象实例时（new）
            ②创建子类对象实例，父类也会被加载
            ③使用类的静态成员时（静态属性，静态方法）例如：A类extendsB类的静态块
        3）普通的代码块，在创建对象实例时，会被隐式的调用。
            被创建一次，就会调用一次。
            如果只是使用类的静态成员时，普通代码块并不会执行。
            小结：
                1.static代码块是类加载时，执行，只会执行一次
                2.普通代码块是在创建对象时调用的，创建一次，调用一次
                3.类加载的3种情况，需要记住.
        4）创建一个对象时，在一个类调用顺序是∶
            ① 调用静态代码块和静态属性初始化（注意∶静态代码块和静态属性初始化调用的优先级一样
                如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）
            ② 调用普通代码块和普通属性的初始化（注意∶普通代码块和普通属性初始化调用的优先级一样
                如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）
            ③ 调用构造方法。
            总结：先静后普再构造（因为类首先要加载 所以静态代码块和属性就优先初始化 然后代码块可以理解为
                 对构造器的一种补充 或者说补充构造器 所以随后初始化 然后才是构造器）
        5）构造器的最前面其实隐含了super（）和调用普通代码块，
              静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的
              public A000 { //构造器
                 //这里有隐藏的执行要求
                （1）super（）∶
                （2）调用普通代码块的System.out.println("ok");
              }
        6）我们看一下创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下∶
            ① 父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
            ② 子类的静态代码块和静态属性（优先级一样，按定义顺序执行）
            ③ 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
            ④ 父类的构造方法
            ⑤ 子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
            ⑥ 子类的构造方法
            总结：类先加载（先执行惊天）  然后再创建对象（先后父类代码块构造器 然后走子类代码块构造器）
        7）静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。
     静态方法和属性的经典运用：单例设计模式
         设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。
         设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索
     单例模式：单例（单个的实例）
         1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中， 对某个类只能存在一个对象实例
            并且该类只提供一个取得其对象实例的方法
         2.单例模式有两种方式∶
            1）饿汉式
            2）懒汉式
         饿汉式单例模式的实现步骤如下∶
            1）构造器私有化=》防止直接new
            2）类的内部创建对象
            3）向外暴露一个静态的公共方法。
            饿汉式创建了 但是没有用 可能导致资源的浪费
         懒汉式单例模式的实现步骤如下∶
            1）构造器私有化=》防止直接new
            2）向外暴露一个静态的公共方法,该方法内部创建对象并返回。
            3）懒汉式，只有当用户使用 getInstance 时，才返回 cat 对象, 后面再次调用时，会返回上次创建的对象从而保证了单例
         两者的区别如下：
            1.二者最主要的区别在于创建对象的时机不同饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。
            2.饿汉式不存在线程安全问题，懒汉式存在线程安全问题。
            3.饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了
              懒汉式是使用时才创建，就不存在这个问题。
            4.在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式

* */

public class Main {
    public static void main(String[] args) {

    }
}

class SingTon01 {
    /*
    * 思路如下：
    *   为了防止new出多个实例 我们选择把构造器私有化
    *   但是私有化之后 外部无法访问了 所以只有我们把对象创建出来 然后return给外部
    *   既然我不能new对象了  那调用的方式肯定是静态调用的方式 所以用static去修饰 所以得到的对象也要用static去修饰
    * */
    private String name;

    private static SingTon01 sgt = new SingTon01("single");

    private SingTon01(String name) {
        this.name = name;
    }
    public SingTon01 getSgt (){
        return sgt;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

class SingTon02 {
    private String name;

    private static SingTon02 sgt;

    public static SingTon02 sgtInstance(){
        if (sgt == null) {
            sgt = new SingTon02("懒汉");
        }
        return sgt;
    }

    private SingTon02(String name) {
        this.name = name;
    }
    public SingTon02 getSgt (){
        return sgt;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}