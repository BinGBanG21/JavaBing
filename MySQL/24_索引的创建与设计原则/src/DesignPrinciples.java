public class DesignPrinciples {
    public static void main(String[] args) {

    }
    /*
    1. 索引的声明与使用
        1.1 索引的分类
            MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。
            从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。
            按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。
            按照 作用字段个数 进行划分，分成单列索引和联合索引。
        不同的存储引擎支持的索引类型也不一样
            InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash 索引；
            MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引；
            Memory ：支持 B-tree、Hash 等 索引，不支持 Full-text 索引；
            NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引；
            Archive ：不支 持 B-tree、Hash、Full-text 等索引；
        1.2 创建索引
            MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句 CREATE TABLE 中指定索引列，使用 ALTER TABLE 语句在存在的表上创建索引，或者使用 CREATE INDEX 语句在已存在的表上添加索引。
            1. 创建表的时候创建索引
                使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。
                * UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；
                * INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；
                * index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；
                * col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；
                * length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；
                * ASC 或 DESC 指定升序或者降序的索引值存储。
            2. 在已经存在的表上创建索引
                在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。
                1. 使用ALTER TABLE语句创建索引** ALTER TABLE语句创建索引的基本语法如下：
                    ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
                    [index_name] (col_name[length],...) [ASC | DESC]
                2. 使用CREATE INDEX创建索引** CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：
                    CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
                    ON table_name (col_name[length],...) [ASC | DESC]
                1.3 删除索引
                    1. 使用ALTER TABLE删除索引**  ALTER TABLE删除索引的基本语法格式如下：
                        ALTER TABLE table_name DROP INDEX index_name;
                    2. 使用DROP INDEX语句删除索引** DROP INDEX删除索引的基本语法格式如下：
                        DROP INDEX index_name ON table_name;
    2. MySQL8.0索引新特性
        2.1 支持降序索引
            降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上DESC定义是被忽略的，
            直到MySQL 8.x版本才开始真正支持降序索引 (仅限于InnoDBc存储引擎)。
            MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。
            例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能
        2.2 隐藏索引
            在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发展删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。
            从MySQL 8.x开始支持 隐藏索引（invisible indexes），只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），
            确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。
    3. 哪些情况适合创建索引
        1. 字段的数值有唯一性的限制
            业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。
            不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。
        2. 频繁作为 WHERE 查询条件的字段
            某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在 数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。
        3. 经常 GROUP BY 和 ORDER BY 的列
            索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立组合索引 。
        4. UPDATE、DELETE 的 WHERE 条件列
            对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。
            如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。
        5.DISTINCT 字段需要创建索引
            有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。
        6. 多表 JOIN 连接操作时，创建索引注意事项
            首先， `连接表的数量尽量不要超过 3 张` ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增 长会非常快，严重影响查询的效率。
            其次， `对 WHERE 条件创建索引` ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下没有WHERE 条件过滤是非常可怕的。
            最后， `对用于连接的字段创建索引` ，并且该字段在多张表中的 类型必须一致 。
        7. 使用列的类型小的创建索引
        8. 使用字符串前缀创建索引
        9. 区分度高(散列性高)的列适合作为索引
            `列的基数` 指的是某一列中不重复数据的个数，在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列简历索引，为基数太小的列的简历索引效果可能不好
        10. 使用最频繁的列放到联合索引的左侧
            这样也可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率
        11. 在多个字段都要创建索引的情况下，联合索引优于单值索引
     4. 哪些情况不适合创建索引
        1. 在where中使用不到的字段，不要设置索引
            WHERE条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。
        2. 数据量小的表最好不要使用索引
            如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引 `对查询效率的影响并不大`。
            甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。
        3. 有大量重复数据的列上不要建立索引
            在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。
            比如在学生表的"性别"字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会`严重降低数据更新速度`。
        4.  避免对经常更新的表创建过多的索引
            第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。
            第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却降低更新表的速度。
        5. 不建议用无序的值作为索引
            例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。
        6. 删除不再使用或者很少使用的索引
            表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。
        7. 不要定义夯余或重复的索引

     */
}
