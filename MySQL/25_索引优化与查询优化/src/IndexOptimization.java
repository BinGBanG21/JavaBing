public class IndexOptimization {
    public static void main(String[] args) {

    }
    /*
    1.都可以进行数据库调优的几个方面
        * 索引失效、没有充分利用到索引——建立索引
        * 关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化
        * 服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf
        * 数据过多——分库分表
        虽然SQL查询优化的技术有很多，但是大方向上完全可以分成`物理查询优化`和`逻辑查询优化`两大块。
            * 物理查询优化是通过`索引`和`表连接方式`等技术来进行优化，这里重点需要掌握索引的使用。
            * 逻辑查询优化就是通过SQL`等价变换`提升查询效率，直白一点就是说，换一种查询写法效率可能更高。
    2.常见的索引优化和索引失效
        1 最佳左前缀法则
            在MySQL建立联合索引时会遵守最佳左前缀原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
            MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序依次满足
            一旦跳过某个字段，索引后面的字段都无法被使用**。如果查询条件中没有用这些字段中第一个字段时，多列（或联合）索引不会被使用。
        2 主键插入顺序
            自定义的主键列 `id` 拥有 `AUTO_INCREMENT` 属性，在插入记录时存储引擎会自动填入自增的主键值。
            这样的主键占用空间小，顺序写入，减少页分裂。
        3 主键插入顺序
            们需要把当前 `页面分裂` 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着性能损耗
            所以如果想尽量避免这样无谓的性能损耗，最好让插入的记录的`主键值依次递增`,这样就不会发生这样的性能损耗了。
        4 计算、函数、类型转换(自动或手动)导致索引失效
        5 类型转换导致索引失效
        6 范围条件右边的列索引失效
        7 不等于(!= 或者<>)索引失效
        8 is null可以使用索引，is not null无法使用索引
        9 like以通配符%开头索引失效
        10 OR 前后存在非索引的列，索引失效
            在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。
            OR前后的两个条件中的列都是索引时，查询中才使用索引。
        总结：
            * 对于单列索引，尽量选择针对当前query过滤性更好的索引
            * 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
            * 在选择组合索引的时候，尽量选择能够当前query中where子句中更多的索引。
            * 在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。
    3. 子查询优化
        MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结 果作为另一个SELECT语句的条件。
        `子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作` 。
        子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。
            ① 执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表 中查询记录。查询完毕后，再 撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。
            ② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会 受到一定的影响。
            ③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。
        在MySQL中，可以使用连接（JOIN）查询来替代子查询。**连接查询 `不需要建立临时表`，其`速度比子查询`要快，如果查询中使用索引的话，性能就会更好。
    4. 排序优化
        在MySQL中，支持两种排序方式，分别是 `FileSort` 和 `Index` 排序。
            * Index 排序中，索引可以保证数据的有序性，不需要再进行排序，`效率更高`。
            * FileSort 排序则一般在 `内存中` 进行排序，占用`CPU较多`。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低。
        优化建议：
            1. SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 `避免全表扫描`.在 ORDER BY 子句 `避免使用 FileSort 排序`。
               当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
            2. 尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。
            3. 无法使用 Index 时，需要对 FileSort 方式进行调优。
    5. GROUP BY优化
        * group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。
        * group by 先排序再分组，遵照索引建的最佳左前缀法则
        * 当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置
        * where效率高于having，能写在where限定的条件就不要写在having中了
        * 减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。
        * 包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。
    6. 优先考虑覆盖索引
        引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。
        毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。
        一个索引包含了满足查询结果的数据就叫做覆盖索引
    7.其它查询优化策略
        关于SELECT(*)
            在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT <字段列表> 查询。原因：
            ① MySQL 在解析的过程中，会通过查询数据字典 将"*"按序转换成所有列名，这会大大的耗费资源和时间。
            ② 无法使用 覆盖索引
        LIMIT 1 对优化的影响
            针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。
            如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。
        多使用COMMIT
            只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放 的资源而减少。
            COMMIT 所释放的资源：
            * 回滚段上用于恢复数据的信息
            * 被程序语句获得的锁
            * redo / undo log buffer 中的空间
            * 管理上述 3 种资源中的内部花费
    
     */
}
