/*
    排序算法
        排序也称排序算(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。
            排序的分类：
            1) 内部排序:
               指将需要处理的所有数据都加载到内部存储器中进行排序。
            2) 外部排序法：
               数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。
    算法的时间复杂度
        1.度量一个程序(算法)执行时间的两种方法
          事后统计的方法
          这种方法可行, 但是有两个问题：
          一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；
          二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,
          这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。
          事前估算的方法
          通过分析某个算法的时间复杂度来判断哪个算法更优.
    时间频度
        时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。
        一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
        忽略常数项
        忽略低次项
        忽略系数
    时间复杂度
        1.一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，
          若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。
          记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )为算法的渐进时间复杂度，简称时间复杂度。
        2.T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n)不同，但时间复杂度相同，都为O(n²)。
        3.计算时间复杂度的方法：
            1.用常数1代替运行时间中的所有加法常数T(n)=n²+7n+6  => T(n)=n²+7n+1
            2.修改后的运行次数函数中，只保留最高阶项T(n)=n²+7n+1 => T(n) = n²
            3.去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)
    常见的时间复杂度
        1.常数阶O(1)
        2.对数阶O(log2n)
        3.线性阶O(n)
        4.线性对数阶O(nlog2n)
        5.平方阶O(n^2)
        6.立方阶O(n^3)
        7.k次方阶O(n^k)
        8.指数阶O(2^n)
        说明：
        1.常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n)
        随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低
        2.我们应该尽可能避免使用指数阶的算法


* */

public class Sort {
    public static void main(String[] args) {

    }
}
