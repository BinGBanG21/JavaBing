/*
     动态规划算法介绍
        1.动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法
        2.动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。
        3.与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。
          (即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)
        4.动态规划可以通过填表的方式来逐步推进，得到最优解


     动态规划算法
        应用场景-背包问题
            背包问题：有一个背包，容量为4磅 ，现有如下物品
            吉他  1磅   1500
            音响  4磅   3000
            电脑  3磅   2000
            1.要求达到的目标为装入的背包的总价值最大，并且重量不超出
            2.要求装入的物品不能重复
            3.思路分析
                背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。
                其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)
                这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。
                算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。
                即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。
                再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：

                  i是行数 j为测试容量 v是二维数组 i是行 也就是物体索引 j是背包临时容量索引
                  (1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0

                  // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略
                  (2) 当w[i]> j 时：v[i][j]=v[i-1][j]

                  (3) 当j>=w[i]时：v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}
                   // 当 准备加入的新增的商品的容量小于等于当前背包的容量,
                   // 装入的方式:
                   v[i-1][j]： 就是上一个单元格的装入的最大值
                   v[i] : 表示当前商品的价值
                   v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值
                   当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} :

* */


public class DynamicProgramming {
    public static void main(String[] args) {
        knapSack();
    }

    public static void knapSack() {

        int m = 4; //背包的总容量
        int[] w = {1, 4, 3}; //物品的重量

        int[] val = {1500, 3000, 2000}; //物品的价格
        int n = val.length; //物品的数量
        //表格 n为物品个数(我们是01背包) m为背包容量 +1是为了让索引和容量对应 比较方便 所以初始化二维数组的时候 要+1
        //v[i][j] 表示该物品装入背包的价值
        int[][] v = new int[n + 1][m + 1];

        //初始化路径 记录物品放入的最终情况
        int[][] path = new int[n + 1][m + 1];
        //初始化第一行第一列默认都是0
        for (int i = 0; i < v.length; i++) {
            v[i][0] = 0; //设置所有行的第一列为0
        }
        for (int i = 0; i < v[0].length; i++) {
            v[0][i] = 0; //设置第一行为0
        }


        for (int i = 1; i < v.length; i++) {  //因为第一行为0 我们不处理 所以从1开始
            for (int j = 0; j < v[0].length; j++) { //同理 不处理0的情况 j是临时容量 v[0].length表示变化的临时容量
                // 我们要尝试填充完成表格
                if (w[i - 1] > j) { //判断容量  如果容量超过 那我们把当前表格填充为上一次的值 也就是包里还放上一次物体
                    v[i][j] = v[i - 1][i - j];
                } else {  //如果背包还有剩余空间 那我们计算两个价值 去较大值填充当前表格
                    //v[i-1] 上一个物品价值 j - w[i - 1] 剩余容量的价值
                    //v[i - 1][j] 上一次的物品价值 因为不知道下一次能不能放得下
                    //val[i] + v[i - 1][j - w[i - 1]]  剩余空间的价值+整个物品的价值
                    //有了剩余空间 就先算一个完整的值 然后再从表格中取出剩余容量的价值
                    //v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
                    //如果上一次放的值小于本次有剩余容量的值 证明剩余的容量又够放入一件物品 那就记录当前的值
                    if (v[i - 1][j] < val[i - 1] + v[i - 1][j - w[i - 1]]) {
                        path[i][j] = 1;
                    } else { //虽有剩余容量 但是容量不够放物品 或者没物品了 那么我们的最终方案还是上一次的结果
                        v[i][j] = v[i - 1][j];
                    }
                }
            }
        }

        //输出结果
        for (int i = 0; i < v.length; i++) {
            for (int j = 0; j < v[0].length; j++) {
                System.out.print(v[i][j] + "  ");
            }
            System.out.println();
        }

        //遍历path 因为我们是在逐步填表 所以会记录好多次 有剩余容量出现且价值高的情况 那么就会记录多次
        //所以为了避免冗余输出 我们值需要最后的遍历情况
        int i = path.length - 1; //行的最大下标
        int j = path[0].length - 1; //列的最大下标
        while (i > 0 && j > 0) {
            if (path[i][j] == 1) {
                System.out.printf("第%d个商品放入到背包\n", i);
                j -= w[i - 1]; //拿出物品
            }
            i--;
        }
    }


}